import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.fluidsonic.cldr.*
import io.fluidsonic.gradle.*
import io.fluidsonic.locale.*
import java.nio.file.*

buildscript {
	repositories {
		jcenter()
		mavenCentral()
		maven("https://dl.bintray.com/fluidsonic/kotlin") // TODO remove once fluid-cldr is included in JCenter
	}

	dependencies {
		classpath("com.squareup:kotlinpoet:1.6.0")
		classpath("io.fluidsonic.cldr:fluid-cldr:0.9.0-37")
		classpath("io.fluidsonic.locale:fluid-locale:0.9.2")
	}
}

fluidLibraryModule(description = "Internationalization data used by fluid-i18n") {
	language {
		withoutExplicitApi() // TODO remove once the new Kotlinpoet release is available
	}

	targets {
		common {
			dependencies {
				api(fluid("locale", "0.9.2"))
			}
		}

		darwin()
		js()
		jvm()
	}
}

tasks {
	val countryNameResolverTask = registerGenerateCountryNameResolverTask(
		resolverName = "CountryNameResolver",
		alternative = CldrCountryNameAlternative.normal
	)
	val countryShortNameResolverTask = registerGenerateCountryNameResolverTask(
		resolverName = "CountryShortNameResolver",
		alternative = CldrCountryNameAlternative.short
	)
	val countryVariantNameResolverTask = registerGenerateCountryNameResolverTask(
		resolverName = "CountryVariantNameResolver",
		alternative = CldrCountryNameAlternative.variant
	)

	register("generateCode") {
		dependsOn(countryNameResolverTask)
		dependsOn(countryShortNameResolverTask)
		dependsOn(countryVariantNameResolverTask)
	}
}


val localizedValueResolverType = ClassName("io.fluidsonic.locale", "LocalizedValueResolver")
	.parameterizedBy(STRING, STRING)


fun TaskContainerScope.registerGenerateCountryNameResolverTask(
	resolverName: String,
	alternative: CldrCountryNameAlternative
): TaskProvider<Task> {
	val taskName = "generate$resolverName"
	val propertyName = resolverName.decapitalize()

	return register(taskName) {
		val generatedDirectory = file("sources/common/country/names/$alternative")
		outputs.dir(generatedDirectory)

		doLast {
			Files.createDirectories(generatedDirectory.toPath())

			// FIXME 2-letter territory IDs may not necessarily represent ISO 3166-1 alpha-2 codes.
			//       We need a correct list somewhere at build time and map this properly.

			val allTags = Cldr.localeIds
				.sorted()
				.map { LanguageTag.parse(it.replace('_', '-')) }
				.groupBy { it.language ?: "root" }

			val fileName = resolverName
			val languagesWithCountryNames = mutableSetOf<String>()

			for ((language, tags) in allTags)
				if (generateCountryNameResolverFileForLanguage(
						language = language,
						tags = tags,
						destination = generatedDirectory.resolve("$fileName.$language.kt"),
						alternative = alternative,
						taskName = taskName,
						propertyName = propertyName
					)
				) {
					languagesWithCountryNames += language
				}

			generateCountryNameResolverFile(
				languages = languagesWithCountryNames.toList(),
				destination = generatedDirectory.resolve("$fileName.kt"),
				resolverName = resolverName,
				taskName = taskName,
				propertyName = propertyName
			)
		}
	}
}


fun generateCountryNameResolverFile(
	languages: List<String>,
	destination: File,
	resolverName: String,
	taskName: String,
	propertyName: String
) {
	destination.outputStream().writer().use { writer ->
		FileSpec.builder(packageName = "io.fluidsonic.i18n.data", fileName = destination.name)
			.addComment("Generated by Gradle task '$taskName'. Do not edit manually.")
			.addImport("io.fluidsonic.locale", "asHierarchical")
			.addProperty(PropertySpec.builder(propertyName, localizedValueResolverType)
				.initializer(buildCodeBlock {
					add("%N.asHierarchical().freeze()", resolverName)
				})
				.build())
			.addType(TypeSpec.objectBuilder(ClassName("io.fluidsonic.i18n.data", resolverName))
				.addModifiers(KModifier.PRIVATE)
				.addSuperinterface(localizedValueResolverType)
				.addProperty(
					PropertySpec.builder(
						name = "resolversByLanguage",
						type = MAP.parameterizedBy(STRING.copy(nullable = true), Lazy::class.asClassName().parameterizedBy(localizedValueResolverType))
					)
						.addModifiers(KModifier.PRIVATE)
						.initializer(buildCodeBlock {
							add("hashMapOf(\n")
							indent()

							for (language in languages) {
								add("%S to atomicLazy { %N },\n", language.takeIf { it != "root" }, "${propertyName}_$language")
							}

							unindent()
							add(")")
						})
						.build()
				)
				.addFunction(FunSpec.builder("resolve")
					.addModifiers(KModifier.OVERRIDE)
					.addParameter("key", STRING)
					.addParameter("language", STRING.copy(nullable = true))
					.addParameter("script", STRING.copy(nullable = true))
					.addParameter("region", STRING.copy(nullable = true))
					.addParameter("variants", LIST.parameterizedBy(STRING))
					.returns(STRING.copy(nullable = true))
					.addStatement("return resolversByLanguage[language]?.value?.resolve(key·=·key,·language·=·language,·script·=·script,·region·=·region,·variants·=·variants)")
					.build()
				)
				.build()
			)
			.build()
			.writeTo(writer)
	}
}


fun generateCountryNameResolverFileForLanguage(
	language: String,
	tags: Collection<LanguageTag>,
	destination: File,
	alternative: CldrCountryNameAlternative,
	taskName: String,
	propertyName: String
): Boolean {
	var hasNames = false

	val initializerBlock = buildCodeBlock {
		beginControlFlow("LocalizedValueResolver.buildMap")

		for (tag in tags)
			for (countryId in Cldr.territoryIds) {
				val name = Cldr.countryName(
					localeId = tag.toString().replace('-', '_'),
					territoryId = countryId,
					alternative = alternative
				) ?: continue

				hasNames = true

				add("put(key·=·%S,·value·=·%S,·language·=·%S", countryId, name, tag.language)

				tag.script?.let { add(",·script·=·%S", it) }
				tag.region?.let { add(",·region·=·%S", it) }
				tag.variants.ifEmpty { null }?.let { add(",·variants·=·listOf(${it.joinToString { "%S" }})", *it.toTypedArray()) }

				add(")\n")
			}

		endControlFlow()
	}

	if (!hasNames)
		return false

	destination.outputStream().writer().use { writer ->
		FileSpec.builder(packageName = "io.fluidsonic.i18n.data", fileName = destination.name)
			.addComment("Generated by Gradle task '$taskName'. Do not edit manually.")
			.addProperty(PropertySpec.builder("${propertyName}_$language", localizedValueResolverType, KModifier.INTERNAL)
				.initializer(initializerBlock)
				.build()
			)
			.build()
			.writeTo(writer)
	}

	return true
}
